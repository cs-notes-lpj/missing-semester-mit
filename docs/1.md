# Course overview + the shell

<iframe width="616" height="347" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" title="Lecture 1: Course Overview + The Shell (2020)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

课程的动机：

这些计算机科学家们非常清楚一件事情，那就是「计算机非常善于处理重复性的任务」

但我们这些普通用户呢？我们往往只知道我们可以编写并执行程序，来让计算机做一些重复性的计算任务

可我们忽略了一点，那就是「计算机善于处理重复性的任务这件事，同样适用于我们对计算机的日常使用」

---

为什么这么说呢？

这是因为：当我们使用计算机时，无论我们在进行什么样的任务，其实都有各种各样的现成的工具来帮助我们更高效

但是很多人都不知道这些工具的存在，或者说很多人都只知道一点点的工具

也有很多人对工具的使用很“表面”，他们往往只是死记硬背了一些魔法咒语般的命令，并且在遇到困难时，只会盲目地从网上复制使用别人写好的命令

> 这门课就是来解决这种现状的 ！

对于你已经知道的工具们，这些计算机科学家会以正确的姿势教给你它们的常见用法

更重要的是：你会了解到一些新的工具，并获得探索更多工具甚至创造工具的激情

---

课程的设计：

这门课由 11 节讲座组成，每一讲都围绕一个[特定的话题](https://cs-notes-lpj.github.io/mit-missing-semester-tools/#/?id=_2020-lectures)

每一节讲座基本上都是独立的，但是随着讲座的持续进行，讲师们会默认你已经熟悉了前面的内容

本讲座总时长 11 小时左右，讲座会涵盖很多不同的内容，所以讲座的进度会很快，全程干货满满

为了让你在课余时间以你自己的节奏熟悉和掌握课程的内容，每节讲座都会设计一些练习题，以帮助你更好地掌握课程的重点知识

网上有讲座的官方笔记和视频回放，但注意课堂上会讲解很多笔记中没有的东西，就比如讲师们的一些演示

---

由于课程时间有限，我们不可能把所有工具的所有细节都讲到

但是，我们会给出一些资源，以便你自己深入探究某个工具或某个话题

如果你遇到任何困难，欢迎在办公时间来我们的办公室向我们寻求帮助

你也可以将你的疑问发送到邮箱：missing-semester@mit.edu

### Shell

what is shell ?

当今世界，计算机给我们提供了各种各样的接口，我们可以使用这些接口和计算机进行人机交互

比如图形用户界面、比如和计算机语音对话、比如增强现实和虚拟现实、...

上述这些接口，在 80% 的使用场景下，都非常好

但是，其实这些接口限制了你对计算机的使用（这些接口允许你做什么，你才能做什么）

比如，如果一个图形用户界面没有给你提供你想要的某个按钮，那你就点不了，你也就用不了某个功能

再比如，如果一个计算机对接收到的某句语音没有做相应的编程处理，那么当你和计算机进行语音对话时，一旦你说的就是这句语音，那么计算机是“听不懂”的，计算机也就不会按照你的要求做事情

为了尽可能地不受这些限制，尽可能地充分利用计算机已经提供的工具

我们需要学习一种基于文本的接口：Shell

---

几乎所有的计算机平台都提供了这样或那样的 shell，并且很多计算机平台都提供了好几种 shell 供你选择

虽然这些 shell 在一些细节上有所不同，但它们的核心都大致相同：它们允许你（执行程序、提供输入、查看输出）

本节课，我们使用 the Bourne Again SHell，简称 “bash”

这是使用最为广泛的一种 shell，你甚至可以发现其它很多 shell 的语法都和 bash 极为相似

shell prompt 是你输入命令的地方，要打开一个 shell prompt，你首先需要一个 terminal

你的计算机很可能已经自带了一个 terminal，当然你也可以自己下载安装一个 terminal，非常容易

---

shell 的基础用法

当你运行你的 terminal，你会看到一个 shell prompt，就像下面这样

```bash
missing:~$
```

这就是 shell 的文本输入接口，它显示出你正处于计算机 `missing` 上，并且你当前的工作路径是 `~`，`~` 是 `home` 的简写，`$` 则说明你当前不是 root user

关于 root user 后续会有相关介绍，你可暂时将 root user 理解为 Windows 中的 Administrator，即超级管理员

你可以在这个 prompt 的后面输入命令，敲击回车后，shell 就会将你输入的命令解释执行

最基本的命令，就是执行程序

```bash
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$
```

看，我们刚刚执行了一个程序，这个程序的名字叫 `date`，它会将当前的日期和时间输出到屏幕上

我们也可以在执行程序时，为其提供参数

```bash
missing:~$ echo hello
hello
```

看，我们执行程序 `echo` 时，为其提供了参数 `hello`

程序 `echo` 仅是简单地将其参数进行输出

---

shell 会以空格来对一条命令进行拆分和解析，进而执行由第一个单词所指示的程序，而后续的单词都是该程序可以访问的参数

如果你希望给程序提供一个含有空格或其他特殊字符的参数（比如你想创建一个名为 "My Photos" 的文件夹），那么你可以使用 `'` 或 `"` 将参数引起来，就像 `"My Photos"` 这样，或者你也可以直接使用 `\` 将相关的字符进行转义，就像 `My\ Photos` 这样

---

你可能会好奇，shell 咋知道从哪找程序 `date` 和 `echo`？

---

其实，shell 同 Python、Ruby 一样，是一种编程环境

这意味着 shell 也有「变量、条件、循环、函数」(下一讲会讲解更多相关内容)

所以，你在 shell prompt 后面所写的东西，其实就是一些能被 shell 解释执行的代码

---

如果你在 shell prompt 后编写的东西不匹配任何一个 shell 的编程关键字

那么 shell 就会向一个环境变量请教，这个环境变量是：`$PATH`

`$PATH` 记录了一些路径，shell 会从这些路径中检索程序

```bash
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ which which
/bin/which
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

从上面可以看出，当我们执行 `echo` 这个命令时，shell 就能知道它应该执行程序 `echo`

然后 shell 就会从 `$PATH` 所记录的路径中检索与 `echo` 这个名字所对应的文件，`$PATH` 所记录的路径们由 `:` 分隔

一旦找到，就会立即执行，当然这里我们假设找到的文件就是一个可执行的文件，后续会有更多介绍

我们可以使用程序 `which` 来确定对于给定的程序名字，到底是那个文件被执行了

我们当然可以直接提供被执行的文件的路径，而不仅仅只提供一个程序的名字，这样就可以绕过 `$PATH`

---

Navigating in the shell：

在 shell 中，“路径” 是一个被分隔的目录列表（这么说有点抽象，具体请看下面的代码）

在 Linux 和 macOS 中，分隔符是 `/`

在 Windows 中，分隔符是 `\`

---

在 Linux 和 macOS 中，路径 `/` 是文件系统的 “根”，所有的文件和文件夹都在其下

但在 Windows 中，每一个磁盘分区都有一个 “根”，比如 `C:\`

> 本讲座会默认你使用的是 Linux 的文件系统

---

以 `/` 开头的路径，被称为绝对路径，其他的路径都被称为相对路径

相对路径是相对当前所在的路径而言的

我们可以执行 `pwd` 命令来查看当前所在的路径

我们可以使用 `cd` 命令来改变当前所在的路径

---

在路径中，`.` 指代当前路径，`..` 指代当前路径的上一级路径（也被称为父目录）

```bash
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

请注意：shell prompt 会始终显示出当前所在的路径，你也可以对 shell prompt 进行配置，以让其显示更多有用的信息，后续的讲座中会有相关介绍

通常，当我们执行一个程序，除非我们告诉这个程序，否则这个程序就会在**当前路径中**进行一系列的操作，比如搜索文件或创建新文件都默认是在当前路径中进行的

---

我们可以使用 `ls` 命令来查看一个给定的路径中都有哪些文件/文件夹

```bash
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

`ls` 默认输出当前路径中的文件/文件夹，除非给其提供一个特定的路径作为第一个参数

大多数的命令都提供了一堆以 `-` 开头的 flags 和 options，可以将 option 看作拥有 value 的 flag

这些 flags 和 options 都可以改变命令的行为表现

通常，执行一个命令的时候，如果为其添加 `-h` 或 `--help` flag，那么就会输出一些帮助信息，这些帮助信息会告诉你有哪些 flags 和 options 是可供使用的

比如，如果执行 `ls --help` 你就能看到如下帮助信息

```bash
-l                         use a long listing format
```

---

```bash
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 foo
```

看，`-l` 这个 flag 能让我们看到文件/文件夹的更多信息

首先，开头的 `d` 表示 missing 是个文件夹

`d` 的后面由 3 个一组共 3 组的 `rwx` 组成，它们表示该文件/文件夹的「所有者missing、用户组users、其他人」对于该文件/文件夹拥有什么样的权限

一个 `-` 表示特定主体无特定权限

在上面这个例子中，只有所有者 missing 拥有对文件夹 foo 的 `w` 权限，即：写权限，即：add/remove files in it

要想能够进入一个目录，则用户必须拥有对该目录和其祖先目录的 search 权限，即 execute 权限，以 `x` 表示

要想能够查看某个目录中都有哪些文件/文件夹，则用户必须拥有对该目录的 read 权限，以 `r` 表示

请注意：在 `/bin` 目录中，几乎所有文件都拥有 `x` 权限 set for the last group

这意味着：任何人都可以执行这些文件

---

还有一些有用的程序，比如：`mv` 可以 rename/move a file，比如：`cp` 可以 copy a file，比如：`mkdir` 可以 make a new directory

如果你想要了解一个程序的更多信息，比如该程序的大致功能、大致使用方式、可用参数、输入输出、...

那么你可以尝试使用 `man` 程序（有事情请找男人 ！）

`man` 接受其他程序的名字作为其参数，然后就会显示出该程序的说明书，按 `q` 退出

```bash
missing:~$ man ls
```

---

connecting programs：

在 shell 中，程序们有 2 个主要的 streams，包括「input stream」和 「output stream」

当程序尝试读取输入，那么它会从 input stream 读取

当程序想要输出一些东西，那么它会输出到 output stream

正常情况下，一个程序的 input 和 output 都是你的 terminal

这就意味着：你的键盘作为 input，你的显示屏作为 output

但是：我们是可以重新连接/重定向这些 stream 的 ！

---

最简单的重定向 stream 的形式是：`< file` 和 `> file`，这二者分别使你能够将 input stream 和 output stream 连接到一个文件

```bash
missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello
```

程序 `cat` 起名于 「concatenates files」

正如上面这个例子所演示的，当我们将文件的名字作为 `cat` 的参数，`cat` 就会将每一个文件的内容按顺序输出到其 output stream

但是，当我们不给 `cat` 提供参数，那么 `cat` 就会从其 input stream 读，进而输出到其 output stream，like in the third example above

你也可以使用 `>>` to append to a file

---

这些输入输出重定向真正闪光的地方在于 the use of pipes

即 operator `|`，它使你能够 “chain” programs，这意味着一个程序的输出可以成为另一个程序的输入

```bash
missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
```

我们将会在 data wrangling 那一节讲座深入探究关于如何充分利用 pipes 的更多细节

---

A versatile and powerful tool：

在大多数 Unix-like systems 上，有一个特殊的用户：the “root” user.

上文中你已经见过它了，the “root” user 几乎不受任何限制，它可以「读取、创建、更新、删除」文件系统中的任何文件

不过，你通常不会以 root 用户的身份登陆你的系统，因为 root 用户很容易意外地破坏某些东西

相反，你应该使用 `sudo` 命令，见名知意，该命令允许你 “do” something “as su”，可将 “su” 看作 “super user” 也即 “root” 的简写

一旦你看到 permission denied errors，通常都是因为你需要以 root 用户的身份/权限来做这件事情

> 但一定请谨小慎微地以 root 用户的身份/权限做事，一定要二次确认你确实需要以这样的方式做这样的事情 ！

---

有一件事你必须以 root 用户的身份/权限来做，那就是向挂载于 /sys 目录下的 sysfs 文件系统做**写**操作

sysfs 将许多内核参数以文件的形式暴露了出来，因此，你能够轻易而快速地重设内核的参数，而不需要借助任何专门的工具

> 请注意在 macOS 和 Windows 上都没有 sysfs

举例如下：

你的笔记本电脑的屏幕的亮度所对应的内核参数就被暴露了出来，对应于在 /sys/class/backlight 目录下的文件 brightness

所以，我们只需向文件 brigtness 中写值，笔记本电脑屏幕的亮度就会被改变

刚开始你可能会尝试像下面这么做

```bash
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

你可能会惊讶于竟然 Permission denied，毕竟我们在执行命令的时候添加了 `sudo`

这时我们就得知道一个很重要的事实了，那就是：`|`、`>`、`<` 这些操作符是由 shell 来负责处理的，而不是被其它任何一个程序，就像 `echo` 程序其实并不知道 `>` 的存在，它只负责从 input stream 读，然后向其 output stream 输出

在上面这个例子中，shell 在尝试向文件 brightness 中写值，写的是什么值呢？是 `sudo echo`'s output

但 shell is authenticated just as your user 而不是 root user

因此这个操作被拒绝了

由此，我们可以将命令改写如下

```bash
$ echo 3 | sudo tee brightness
```

由于程序 `tee` 是以 root user 的身份/权限执行的，因此 `tee` 就被允许打开 /sys 目录下的文件进行写操作，所以上面这条命令生效了

---

你可以通过操作 /sys 目录来控制实现一些有意思且 useful 的东西，就比如你可以控制你的计算机上的 LED 灯的亮灭状态，就像下面这样做

```bash
$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
```

---

Next steps：

至此，你已经了解了 shell 的基本用法，相信你已经可以做一些基本的操作，应对一些基本的任务

你应该已经能够四处导航来查找你感兴趣的文件，并且能够使用大多数程序的基本功能

在下一节讲座中，我们会围绕如何使用 shell 来执行和自动化更复杂的任务这件事来展开讨论

我们也将介绍很多在命令行中使用的趁手的程序软件/工具软件

