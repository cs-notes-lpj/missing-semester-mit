# Course overview + the shell

<iframe width="616" height="347" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" title="Lecture 1: Course Overview + The Shell (2020)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

课程的动机：

这些计算机科学家们非常清楚一件事情，那就是「计算机非常善于处理重复性的任务」

但我们这些普通用户呢？我们往往只知道我们可以编写并执行程序，来让计算机做一些重复性的计算任务

可我们忽略了一点，那就是「计算机善于处理重复性的任务这件事，同样适用于我们对计算机的日常使用」

---

为什么这么说呢？

这是因为：当我们使用计算机时，无论我们在进行什么样的任务，其实都有各种各样的现成的工具来帮助我们更高效

但是很多人都不知道这些工具的存在，或者说很多人都只知道一点点的工具

也有很多人对工具的使用很“表面”，他们往往只是死记硬背了一些魔法咒语般的命令，并且在遇到困难时，只会盲目地从网上复制使用别人写好的命令

> 这门课就是来解决这种现状的 ！

对于你已经知道的工具们，这些计算机科学家会以正确的姿势教给你它们的常见用法

更重要的是：你会了解到一些新的工具，并获得探索更多工具甚至创造工具的激情

---

课程的设计：

这门课由 11 节讲座组成，每一讲都围绕一个[特定的话题](https://cs-notes-lpj.github.io/mit-missing-semester-tools/#/?id=_2020-lectures)

每一节讲座基本上都是独立的，但是随着讲座的持续进行，讲师们会默认你已经熟悉了前面的内容

本讲座总时长 11 小时左右，讲座会涵盖很多不同的内容，所以讲座的进度会很快，全程干货满满

为了让你在课余时间以你自己的节奏熟悉和掌握课程的内容，每节讲座都会设计一些练习题，以帮助你更好地掌握课程的重点知识

网上有讲座的官方笔记和视频回放，但注意课堂上会讲解很多笔记中没有的东西，就比如讲师们的一些演示

---

由于课程时间有限，我们不可能把所有工具的所有细节都讲到

但是，我们会给出一些资源，以便你自己深入探究某个工具或某个话题

如果你遇到任何困难，欢迎在办公时间来我们的办公室向我们寻求帮助

你也可以将你的疑问发送到邮箱：missing-semester@mit.edu

### Shell

what is shell ?

当今世界，计算机给我们提供了各种各样的接口，我们可以使用这些接口和计算机进行人机交互

比如图形用户界面、比如和计算机语音对话、比如增强现实和虚拟现实、...

上述这些接口，在 80% 的使用场景下，都非常好

但是，其实这些接口限制了你对计算机的使用（这些接口允许你做什么，你才能做什么）

比如，如果一个图形用户界面没有给你提供你想要的某个按钮，那你就点不了，你也就用不了某个功能

再比如，如果一个计算机对接收到的某句语音没有做相应的编程处理，那么当你和计算机进行语音对话时，一旦你说的就是这句语音，那么计算机是“听不懂”的，计算机也就不会按照你的要求做事情

为了尽可能地不受这些限制，尽可能地充分利用计算机已经提供的工具

我们需要学习一种基于文本的接口：Shell

---

几乎所有的计算机平台都提供了这样或那样的 shell，并且很多计算机平台都提供了好几种 shell 供你选择

虽然这些 shell 在一些细节上有所不同，但它们的核心都大致相同：它们允许你（执行程序 with arguments、提供输入、查看输出），arguments 能够改变程序的 behavior

本节课，我们使用 the Bourne Again SHell，简称 “bash”

这是使用最为广泛的一种 shell，你甚至可以发现其它很多 shell 的语法都和 bash 极为相似

shell prompt 是你输入命令的地方，要打开一个 shell prompt，你首先需要一个 terminal

你的计算机很可能已经自带了一个 terminal，当然你也可以自己下载安装一个 terminal，非常容易

---

shell 的基础用法

当你运行你的 terminal，你会看到一个 shell prompt，就像下面这样

```bash
missing:~$
```

这就是 shell 的文本输入接口，它显示出你正处于计算机 `missing` 上，并且你当前的工作路径是 `~`，`~` 是 `home` 的简写，`$` 则说明你当前不是 root user

关于 root user 后续会有相关介绍，你可暂时将 root user 理解为 Windows 中的 Administrator，即超级管理员

你可以在这个 prompt 的后面输入命令，敲击回车后，shell 就会将你输入的命令解释执行

最基本的命令，就是执行程序

```bash
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$
```

看，我们刚刚执行了一个程序，这个程序的名字叫 `date`，它会将当前的日期和时间输出到屏幕上

我们也可以在执行程序时，为其提供参数

```bash
missing:~$ echo hello
hello
```

看，我们执行程序 `echo` 时，为其提供了参数 `hello`

程序 `echo` 仅是简单地将其参数进行输出

---

shell 会以空格来对一条命令进行拆分和解析，进而执行由第一个单词所指示的程序，而后续的单词都是该程序可以访问的参数

如果你希望给程序提供一个含有空格或其他特殊字符的参数（比如你想创建一个名为 "My Photos" 的文件夹），那么你可以使用 `'` 或 `"` 将参数引起来，就像 `"My Photos"` 这样，或者你也可以直接使用 `\` 将相关的字符进行转义，就像 `My\ Photos` 这样

> 单引号和双引号的区别会在下一节讲座中讲解

---

你可能会好奇，shell 是怎么知道这些程序都是个啥，shell 又是怎么知道像 `date` 和 `echo` 这些程序它们会做什么，shell 怎么知道这些程序都在哪

其实：你的电脑在刚买回来的时候就已经内置了一些程序，就比如它可能自带 the terminal app，也可能自带浏览器，当然它也内置了一些围绕着 terminal 的 applications

这些程序都存储在你电脑的 file system 中

你的 shell 是有一种机制去搜索程序的，这种检索程序的机制借助一个叫做环境变量的东西来实现

环境变量就像你使用编程语言时的变量，这说明 shell 其实同 Python、Ruby 一样，是一种编程语言

这意味着你不仅可以在 shell prompt 后 run program with arguments，你还可以 do things like 「while loops、for loops、conditionals、define functions、variables、...」

所以，你在 shell prompt 后面所写的东西，其实就是一些能被 shell 解释执行的代码

下一节讲座会讲更多相关内容

---

Environment Variables are things that are set whenever you start your shell

比如「where is your home directory、what is your username、...」

they are not things you have to set every time you run your shell

---

如果你在 shell prompt 后编写的东西不匹配任何一个 shell 的编程关键字

那么 shell 就会向一个环境变量请教，这个环境变量是：`$PATH`

`$PATH` 记录了一些路径，shell 会从这些路径中检索程序

```bash
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ which which
/bin/which
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

从上面可以看出，当我们执行 `echo` 这个命令时，shell 就能知道它应该执行程序 `echo`

然后 shell 就会从 `$PATH` 所记录的路径中检索与 `echo` 这个名字所匹配的程序或文件，`$PATH` 所记录的路径们由 `:` 分隔

一旦找到，就会立即执行，当然这里我们假设找到的文件就是一个可执行的文件，后续会有更多介绍

我们可以使用程序 `which` 来确定对于给定的程序名字，到底是那个文件被执行了

我们当然可以直接提供被执行的文件的路径，而不仅仅只提供一个程序的名字，这样就可以绕过 `$PATH`

---

> paths are a way to name the location of a file on your computer

On Linux and macOS, these paths are seperated by `/`

On Windows，these paths are seperated by `\`

---

在 Linux 和 macOS 中，路径 `/` 是文件系统的 “根”，所有的文件和文件夹都在其下

但在 Windows 中，每一个磁盘分区都有一个 “根”，比如 `C:\`

> 本讲座会默认你使用的是 Linux 的文件系统

---

以 `/` 开头的路径，被称为绝对路径，其他的路径都被称为相对路径

absolute paths are paths that fully determine the location of a file

a relative path is relative to where you currently are

相对路径是相对当前所在的路径而言的

我们可以执行 `pwd` 命令来查看当前所在的路径，即：`p`rint `w`orking `d`irectory

我们可以使用 `cd` 命令来改变当前所在的路径，即：`c`hange `d`irectory

---

`.` means the current directory, `..` means the parent directory

```bash
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

请注意：shell prompt 会始终显示出当前所在的路径，你也可以对 shell prompt 进行配置，以让其显示更多有用的信息，后续的讲座中会有相关介绍

通常，当我们执行一个程序，除非我们告诉这个程序，否则这个程序就会在**当前路径中**进行一系列的操作，比如搜索文件或创建新文件都默认是在当前路径中进行的

---

我们可以使用 `ls` 命令来查看一个给定的路径中都有哪些文件/文件夹

```bash
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

`ls` 默认输出当前路径中的文件/文件夹，除非给其提供一个特定的路径作为第一个参数

大多数的命令都提供了一堆以 `-` 开头的 flags 和 options，可以将 option 看作拥有 value 的 flag

这些 flags 和 options 都可以改变命令的行为表现

通常，执行一个命令的时候，如果为其添加 `-h` 或 `--help` flag，那么就会输出一些帮助信息，这些帮助信息会告诉你有哪些 flags 和 options 是可供使用的

比如，如果执行 `ls --help` 你就能看到如下帮助信息

```bash
-l                         use a long listing format
```

---

```bash
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 foo
```

看，`-l` 这个 flag 能让我们看到文件/文件夹的更多信息

首先，开头的 `d` 表示 missing 是个文件夹

`d` 的后面由 3 个一组共 3 组的 `rwx` 组成，它们表示该文件/文件夹的「所有者missing、用户组users、其他人」对于该文件/文件夹拥有什么样的权限

一个 `-` 表示特定主体无特定权限

在上面这个例子中，只有所有者 missing 拥有对文件夹 foo 的 `w` 权限，即：写权限，即：rename/create/remove files in it

要想能够进入一个目录，则用户必须拥有对该目录和其祖先目录的 search 权限，即 execute 权限，以 `x` 表示

要想能够查看某个目录中都有哪些文件/文件夹，则用户必须拥有对该目录的 read 权限，以 `r` 表示

请注意：在 `/bin` 目录中，几乎所有文件都拥有 `x` 权限 set for the last group

这意味着：任何人都可以执行这些文件

---

还有一些有用的程序，比如：`mv` 可以 rename/move a file，比如：`cp` 可以 copy a file，比如：`mkdir` 可以 make a new directory

如果你想要了解一个程序的更多信息，比如该程序的大致功能、大致使用方式、可用参数、输入输出、...

那么你可以尝试使用 `man` 程序（~有事情请找男人 ！~ 其实是 **man**ual pages）

`man` 接受其他程序的名字作为其参数，然后就会显示出该程序的说明书，按 `q` 退出

```bash
missing:~$ man ls
```

---

connecting programs：

在 shell 中，程序们有 2 个主要的 streams，包括「input stream」和 「output stream」

当程序尝试读取输入，那么它会从 input stream 读取

当程序想要输出一些东西，那么它会输出到 output stream

正常情况下，一个程序的 input 和 output 都是你的 terminal

这就意味着：你的键盘作为 input，你的显示屏作为 output

但是：我们是可以重新连接/重定向这些 stream 的 ！

---

最简单的重定向 stream 的形式是：`< file` 和 `> file`，这二者分别使你能够将 input stream 和 output stream 连接到一个文件

```bash
missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello
```

程序 `cat` 起名于 「concatenates files」

正如上面这个例子所演示的，当我们将文件的名字作为 `cat` 的参数，`cat` 就会将每一个文件的内容按顺序输出到其 output stream

但是，当我们不给 `cat` 提供参数，那么 `cat` 就会从其 input stream 读，进而输出到其 output stream，like in the third example above

你也可以使用 `>>` to append to a file

---

这些输入输出重定向真正闪光的地方在于 the use of pipes

即 operator `|`，它使你能够 “chain” programs，这意味着一个程序的输出可以成为另一个程序的输入

```bash
missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
```

我们将会在 data wrangling 那一节讲座深入探究关于如何充分利用 pipes 的更多细节

---

A versatile and powerful tool：

在大多数 Unix-like systems 上，有一个特殊的用户：the “root” user.

上文中你已经见过它了，the “root” user 不受任何限制，它可以「读取、创建、更新、删除」文件系统中的任何文件

不过，你通常不会以 root 用户的身份登陆你的系统，因为 root 用户很容易意外地破坏某些东西

相反，你应该使用 `sudo` 命令，见名知意，该命令允许你 “do” something “as su”，可将 “su” 看作 “super user” 也即 “root” 的简写

一旦你看到 permission denied errors，通常都是因为你需要以 root 用户的身份/权限来做这件事情

> 但一定请谨小慎微地以 root 用户的身份/权限做事，一定要二次确认你确实需要以这样的方式做这样的事情 ！

---

有一件事你必须以 root 用户的身份/权限来做，那就是向挂载于 /sys 目录下的 sysfs 文件系统做**写**操作

sysfs 将许多内核参数以文件的形式暴露了出来，因此，你能够轻易而快速地重设内核的参数，而不需要借助任何专门的工具

> 请注意在 macOS 和 Windows 上都没有 sysfs

举例如下：

你的笔记本电脑的屏幕的亮度所对应的内核参数就被暴露了出来，对应于在 /sys/class/backlight 目录下的文件 brightness

所以，我们只需向文件 brigtness 中写值，笔记本电脑屏幕的亮度就会被改变

刚开始你可能会尝试像下面这么做

```bash
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

你可能会惊讶于竟然 Permission denied，毕竟我们在执行命令的时候添加了 `sudo`

这时我们就得知道一个很重要的事实了，那就是：`|`、`>`、`<` 这些操作符是由 shell 来负责处理的，而不是被其它任何一个程序，就像 `echo` 程序其实并不知道 `>` 的存在，它只负责从 input stream 读，然后向其 output stream 输出

在上面这个例子中，shell 在尝试向文件 brightness 中写值，写的是什么值呢？是 `sudo echo`'s output

但 shell is authenticated just as your user 而不是 root user

因此这个操作被拒绝了

由此，我们可以将命令改写如下

```bash
$ echo 3 | sudo tee brightness
```

由于程序 `tee` 是以 root user 的身份/权限执行的，因此 `tee` 就被允许打开 /sys 目录下的文件进行写操作，所以上面这条命令生效了

---

你可以通过操作 /sys 目录来控制实现一些有意思且 useful 的东西，就比如你可以控制你的计算机上的 LED 灯的亮灭状态，就像下面这样做

```bash
$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
```

---

Next steps：

至此，你已经了解了 shell 的基本用法，相信你已经可以做一些基本的操作，应对一些基本的任务

你应该已经能够四处导航来查找你感兴趣的文件，并且能够使用大多数程序的基本功能

在下一节讲座中，我们会围绕如何使用 shell 来执行和自动化更复杂的任务这件事来展开讨论

我们也将介绍很多在命令行中使用的趁手的程序软件/工具软件

### Notes on the class

计算机除了擅长做一些重复性的工作以外，也非常擅长自动化一些东西，即：Automating things

---

通常情况下，相对路径和绝对路径哪个短用哪个

但是，举个例子，如果你写了一个程序，这个程序中会运行其它程序，比如 `echo` 或 `date`

那么如果你想让你写的程序随处可运行，你就不能在你写的程序中使用相对路径

你可以在你写的程序中给出你要运行的程序的名字，让 shell 使用 $PATH 来知道该程序在哪

或者你也可以在你写的程序中给出你要运行的程序的绝对路径

---

`~` == `/home/xxx`

if you do `cd -`，it will cd to the directory you were previously in

---

pipes are not just for textual data, you can do this for things like images as well

you can have a program that manipulates a binary image on its input and writes a binary image to its output, and you can chain them together in this way.

---

the user ID of the "root" user is `0`

the `$` in the shell prompt means that the shell is running as normal user

the `#` in the shell prompt means that the shell is running as root user

---

对内核参数的设置一定要谨小慎微，必须搞清楚你的操作会导致什么效果甚至后果，再决定是否要设置内核参数

---

`xdg-open` on Linux, `open` on macOS

### Exercises after the class

All classes in this course are accompanied by a series of exercises. Some give you a specific task to do, while others are open-ended, like “try using X and Y programs”. We highly encourage you to try them out.

We have not written solutions for the exercises. If you are stuck on anything in particular, feel free to send us an email describing what you’ve tried so far, and we will try to help you out.

1、For this course, you need to be using a Unix shell like Bash or ZSH. If you are on Linux or macOS, you don’t have to do anything special. If you are on Windows, you need to make sure you are not running cmd.exe or PowerShell; you can use [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/) or a Linux virtual machine to use Unix-style command-line tools. To make sure you’re running an appropriate shell, you can try the command `echo $SHELL`. If it says something like `/bin/bash` or `/usr/bin/zsh`, that means you’re running the right program.

2、Create a new directory called `missing` under `/tmp`.

3、Look up the `touch` program. The `man` program is your friend.

4、Use `touch` to create a new file called `semester` in `missing`.

5、Write the following into that file, one line at a time: 

```bash
#!/bin/sh
curl --head --silent https://missing.csail.mit.edu
```

The first line might be tricky to get working. It’s helpful to know that `#` starts a comment in Bash, and `!` has a special meaning even within double-quoted (`"`) strings. Bash treats single-quoted strings (`'`) differently: they will do the trick in this case. See the Bash [quoting](https://www.gnu.org/software/bash/manual/html_node/Quoting.html) manual page for more information.

6、Try to execute the file, i.e. type the path to the script (`./semester`) into your shell and press enter. Understand why it doesn’t work by consulting the output of `ls` (hint: look at the permission bits of the file).

7、Run the command by explicitly starting the `sh` interpreter, and giving it the file `semester` as the first argument, i.e. `sh semester`. Why does this work, while `./semester` didn’t?

8、Look up the `chmod` program (e.g. use `man chmod`).

9、Use `chmod` to make it possible to run the command `./semester` rather than having to type `sh semester`. How does your shell know that the file is supposed to be interpreted using `sh`? See this page on the [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) line for more information.

10、Use `|` and `>` to write the “last modified” date output by `semester` into a file called `last-modified.txt` in your home directory.

11、Write a command that reads out your laptop battery’s power level or your desktop machine’s CPU temperature from `/sys`. Note: if you’re a macOS user, your OS doesn’t have sysfs, so you can skip this exercise.

