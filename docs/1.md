# Course overview + the shell

<iframe width="616" height="347" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" title="Lecture 1: Course Overview + The Shell (2020)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

课程的动机：

这些计算机科学家们非常清楚一件事情，那就是「计算机非常善于处理重复性的任务」

但我们这些普通用户呢？我们往往只知道我们可以编写并执行程序，来让计算机做一些重复性的计算任务

可我们忽略了一点，那就是「计算机善于处理重复性的任务这件事，同样适用于我们对计算机的日常使用」

---

为什么这么说呢？

这是因为：当我们使用计算机时，无论我们在进行什么样的任务，其实都有各种各样的现成的工具来帮助我们更高效

但是很多人都不知道这些工具的存在，或者说很多人都只知道一点点的工具

也有很多人对工具的使用很“表面”，他们往往只是死记硬背了一些魔法咒语般的命令，并且在遇到困难时，只会盲目地从网上复制使用别人写好的命令

> 这门课就是来解决这种现状的 ！

对于你已经知道的工具们，这些计算机科学家会以正确的姿势教给你它们的常见用法

更重要的是：你会了解到一些新的工具，并获得探索更多工具甚至创造工具的激情

---

课程的设计：

这门课由 11 节讲座组成，每一讲都围绕一个[特定的话题](https://cs-notes-lpj.github.io/mit-missing-semester-tools/#/docs/1?id=_2020-lectures)

每一节讲座基本上都是独立的，但是随着讲座的持续进行，讲师们会默认你已经熟悉了前面的内容

本讲座总时长 11 小时左右，讲座会涵盖很多不同的内容，所以讲座的进度会很快，全程干货满满

为了让你在课余时间以你自己的节奏熟悉和掌握课程的内容，每节讲座都会设计一些练习题，以帮助你更好地掌握课程的重点知识

网上有讲座的官方笔记和视频回放，但注意课堂上会讲解很多笔记中没有的东西，就比如讲师们的一些演示

---

由于课程时间有限，我们不可能把所有工具的所有细节都讲到

但是，我们会给出一些资源，以便你自己深入探究某个工具或某个话题

如果你遇到任何困难，欢迎在办公时间来我们的办公室向我们寻求帮助

你也可以将你的疑问发送到邮箱：missing-semester@mit.edu

### Shell

what is shell ?

当今世界，计算机给我们提供了各种各样的接口，我们可以使用这些接口和计算机进行人机交互

比如图形用户界面、比如和计算机语音对话、比如增强现实和虚拟现实、...

上述这些接口，在 80% 的使用场景下，都非常好

但是，其实这些接口限制了你对计算机的使用（这些接口允许你做什么，你才能做什么）

比如，如果一个图形用户界面没有给你提供你想要的某个按钮，那你就点不了，你也就用不了某个功能

再比如，如果一个计算机对接收到的某句语音没有做相应的编程处理，那么当你和计算机进行语音对话时，一旦你说的就是这句语音，那么计算机是“听不懂”的，计算机也就不会按照你的要求做事情

为了尽可能地不受这些限制，尽可能地充分利用计算机已经提供的工具

我们需要学习一种基于文本的接口：Shell

---

几乎所有的计算机平台都提供了这样或那样的 shell，并且很多计算机平台都提供了好几种 shell 供你选择

虽然这些 shell 在一些细节上有所不同，但它们的核心都大致相同：它们允许你（执行程序、提供输入、查看输出）

本节课，我们使用 the Bourne Again SHell，简称 “bash”

这是使用最为广泛的一种 shell，你甚至可以发现其它很多 shell 的语法都和 bash 极为相似

shell prompt 是你输入命令的地方，要打开一个 shell prompt，你首先需要一个 terminal

你的计算机很可能已经自带了一个 terminal，当然你也可以自己下载安装一个 terminal，非常容易

---

shell 的基础用法

当你运行你的 terminal，你会看到一个 shell prompt，就像下面这样

```bash
missing:~$
```

这就是 shell 的文本输入接口，它显示出你正处于计算机 `missing` 上，并且你当前的工作路径是 `~`，`~` 是 `home` 的简写，`$` 则说明你当前不是 root user

关于 root user 后续会有相关介绍，你可暂时将 root user 理解为 Windows 中的 Administrator，即超级管理员

你可以在这个 prompt 的后面输入命令，敲击回车后，shell 就会将你输入的命令解释执行

最基本的命令，就是执行程序

```bash
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$
```

看，我们刚刚执行了一个程序，这个程序的名字叫 `date`，它会将当前的日期和时间输出到屏幕上

我们也可以在执行程序时，为其提供参数

```bash
missing:~$ echo hello
hello
```

看，我们执行程序 `echo` 时，为其提供了参数 `hello`

程序 `echo` 仅是简单地将其参数进行输出

---

shell 会以空格来对一条命令进行拆分和解析，进而执行由第一个单词所指示的程序，而后续的单词都是该程序可以访问的参数

如果你希望给程序提供一个含有空格或其他特殊字符的参数（比如你想创建一个名为 "My Photos" 的文件夹），那么你可以使用 `'` 或 `"` 将参数引起来，就像 `"My Photos"` 这样，或者你也可以直接使用 `\` 将相关的字符进行转义，就像 `My\ Photos` 这样

---

你可能会好奇，shell 咋知道从哪找程序 `date` 和 `echo`？

---

其实，shell 同 Python、Ruby 一样，是一种编程环境

这意味着 shell 也有「变量、条件、循环、函数」(下一讲会讲解更多相关内容)

所以，你在 shell prompt 后面所写的东西，其实就是一些能被 shell 解释执行的代码

---

如果你在 shell prompt 后编写的东西不匹配任何一个 shell 的编程关键字

那么 shell 就会向一个环境变量请教，这个环境变量是：`$PATH`

`$PATH` 记录了一些路径，shell 会从这些路径中检索程序

```bash
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ which which
/bin/which
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

从上面可以看出，当我们执行 `echo` 这个命令时，shell 就能知道它应该执行程序 `echo`

然后 shell 就会从 `$PATH` 所记录的路径中检索与 `echo` 这个名字所对应的文件，`$PATH` 所记录的路径们由 `:` 分隔

一旦找到，就会立即执行，当然这里我们假设找到的文件就是一个可执行的文件，后续会有更多介绍

我们可以使用程序 `which` 来确定对于给定的程序名字，到底是那个文件被执行了

我们当然可以直接提供被执行的文件的路径，而不仅仅只提供一个程序的名字，这样就可以绕过 `$PATH`

---

Navigating in the shell：

在 shell 中，“路径” 是一个被分隔的目录列表（这么说有点抽象，具体请看下面的代码）

在 Linux 和 macOS 中，分隔符是 `/`

在 Windows 中，分隔符是 `\`

---

在 Linux 和 macOS 中，路径 `/` 是文件系统的 “根”，所有的文件和文件夹都在其下

但在 Windows 中，每一个磁盘分区都有一个 “根”，比如 `C:\`

> 本讲座会默认你使用的是 Linux 的文件系统

---

以 `/` 开头的路径，被称为绝对路径，其他的路径都被称为相对路径

相对路径是相对当前所在的路径而言的

我们可以执行 `pwd` 命令来查看当前所在的路径

我们可以使用 `cd` 命令来改变当前所在的路径

---

在路径中，`.` 指代当前路径，`..` 指代当前路径的上一级路径（也被称为父目录）

```bash
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

请注意：shell prompt 会始终显示出当前所在的路径，你也可以对 shell prompt 进行配置，以让其显示更多有用的信息，后续的讲座中会有相关介绍

通常，当我们执行一个程序，除非我们告诉这个程序，否则这个程序就会在当前路径中进行一系列的操作

比如搜索文件或创建新文件都默认是在当前路径中进行的

---

我们可以使用 `ls` 命令来查看一个给定的路径中都有哪些文件/文件夹

```bash
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

`ls` 默认输出当前路径中的文件/文件夹，除非给其提供一个特定的路径作为第一个参数

大多数的命令都提供了一堆以 `-` 开头的 flags 和 options，可以将 option 看作拥有 value 的 flag

这些 flags 和 options 都可以改变命令的行为表现

通常，执行一个命令的时候，如果为其添加 `-h` 或 `--help` flag，那么就会输出一些帮助信息，这些帮助信息中会告诉你有哪些 flags 和 options 是可供使用的

比如，如果执行 `ls --help` 你就能看到如下帮助信息

```bash
-l                         use a long listing format
```

---

```bash
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
```



### 2020 Lectures

- 1/13: Course overview + the shell

- 1/14: Shell Tools and Scripting

- 1/15: Editors (Vim)

- 1/16: Data Wrangling

- 1/21: Command-line Environment

- 1/22: Version Control (Git)

- 1/23: Debugging and Profiling

- 1/27: Metaprogramming (build systems, dependency management, testing, CI)

- 1/28: Security and Cryptography

- 1/29: Potpourri

- 1/30: Q&A

> 在 YOUTUBE 上可以看课程讲座的[视频回放](https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J)，尽管本课程每一年的内容都略有不同，但仍然建议学习年份较新的版本，也正是由于每一年的内容都略有不同，因此 2019 年的版本仍然支持[访问](https://missing.csail.mit.edu/2019/)

